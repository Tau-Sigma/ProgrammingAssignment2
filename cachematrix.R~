## The functions take a matrix and produce its inverse, which is then stored.
## In case the function makeCacheMartix was used again to create a matrix the cacheSolve function calculates a new inverse. Otherwise it hands over the stored inverse

## The makeCacheMatrix function creates a list containing a function to
##    set the matrix
##    get the matrix
##    set the inverse
##    get the inverse


makeCacheMatrix <- function(x = matrix()) {
        Inv <- NULL
        setmatrix <- function(y) {
                x <<- y
                Inv <<- NULL
        }
        getmatrix <- function() x
        setinverse <- function(inverse) Inv <<- inverse
        getinverse <- function() Inv
        list(setmatrix = setmatrix,
             getmatrix = getmatrix,
             setinverse = setinverse,
             getinverse = getinverse)
}


## The following function calculates the inverse of the matrix handed to the above function. Before
## doing this it actually checks to see if the inverse has already been calculated. If so, it gets
## the inverse from the cache and skips the computation. Otherwise, it calculates the inverse of the data and sets the value of the inverse in the cache via the setinverse function.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        Inv <- x$getinverse()
        if(!is.null(Inv)) {
                message("getting cached inverse")
                return(Inv)
        }
        data <- x$getmatrix()
        Inv <- solve(data)
        x$setinverse(Inv)
        Inv
}
